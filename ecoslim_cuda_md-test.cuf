module particles_para_cuda_m
  !real*8,texture,pointer::dz_T(:),EvapTrans_T(:,:,:)
  !real*8,texture,pointer::Vx_T(:,:,:),Vy_T(:,:,:),Vz_T(:,:,:)
  !real*8,texture,pointer::Saturation_T(:,:,:),Porosity_T(:,:,:)
contains
 attributes(global) subroutine particles_independent(&
 P,C,dz_T,EvapTrans_T,Vx_T,Vy_T,Vz_T,Saturation_T,Porosity_T,&
 out_age,out_mass,out_comp,et_age,et_mass,et_comp,&
 out_np,et_np,Ind_T,kk,np_ps,nx,ny,nz,pfnt,nind,&
 pfdt,moldiff,dx,dy,denh2o,dtfrac,xmin,ymin,zmin,&
 xmax,ymax,zmax,rank)

  implicit none

  integer,parameter::block_size = 256
  real*8,intent(inout)::P(:,:),C(:,:,:,:)
  real*8,intent(in)::dz_T(:),EvapTrans_T(:,:,:),Vx_T(:,:,:),Vy_T(:,:,:)
  real*8,intent(in)::Vz_T(:,:,:),Saturation_T(:,:,:),Porosity_T(:,:,:),Ind_T(:,:,:)
  real*8,shared::P_s(block_size,12+2*nind)

  integer,value::kk,np_ps,nx,ny,nz,pfnt,rank,nind
  real*8,value::pfdt,moldiff,dx,dy,denh2o,dtfrac
  real*8,value::xmin,ymin,zmin,xmax,ymax,zmax

  integer::ii,ii_g,k,itime_loc,index1,Ploc(3),ir,temp2
  real*8::Clocx,Clocy,Clocz,Vpx,Z,Vpy,Vpz,&
  particledt,delta_time,local_flux,et_flux,water_vol,advdt(3),&
  z1,z2,z3,Zr,temp,lock,Ltemp

  !global
  real*8,intent(inout)::out_age(:),out_mass(:),out_comp(:),&
  et_age(:),et_mass(:),et_comp(:)
  integer,intent(inout)::out_np(:),et_np(:)

  !shared in the block
  !real*8,shared::out_age_s(block_size),out_mass_s(block_size),&
  !out_comp1_s(block_size),out_comp2_s(block_size),out_comp3_s(block_size)
  !real*8,shared::et_age_s(block_size),et_mass_s(block_size),&
  !et_comp1_s(block_size),et_comp2_s(block_size),et_comp3_s(block_size)
  !integer,shared::out_np_s(block_size),et_np_s(block_size)

  !private for each thread
  !real*8::out_age_p,out_mass_p,out_comp1_p,out_comp2_p,out_comp3_p
  !real*8::et_age_p,et_mass_p,et_comp1_p,et_comp2_p,et_comp3_p
  !integer::out_np_p,et_np_p

  !for random number
  real*8 r(97),rm1,rm2
  integer j
  integer iff,ix1,ix2,ix3
  iff = 0

  lock = 1.
!=============================================================================
  !out_age_p   = 0.d0
  !out_mass_p  = 0.d0
  !out_comp1_p = 0.d0
  !out_comp2_p = 0.d0
  !out_comp3_p = 0.d0
  !et_age_p    = 0.d0
  !et_mass_p   = 0.d0
  !et_comp1_p  = 0.d0
  !et_comp2_p  = 0.d0
  !et_comp3_p  = 0.d0
  !out_np_p    = 0
  !et_np_p     = 0
!=============================================================================
  index1 = (blockIdx%x - 1) * blockDim%x + threadIdx%x
  ii = threadIdx%x
!if(index1==1) then
!  C = 0.d0
!  out_age = 0.d0
!  out_mass = 0.d0
!  out_comp = 0.d0
!  et_age = 0.d0
!  et_mass = 0.d0
!  et_comp = 0.d0
!  out_np = 0
!  et_np = 0
!end if
!call syncthreads()
  do ii_g = index1, np_ps, blockDim%x * gridDim%x

    P_s(ii,:) = P(ii_g,:)
    !call syncthreads()
!=============================================================================
    ir = -(932117 + np_ps*rank + ii_g + 100*kk)

    delta_time = 0.d0

    if(P_s(ii,8) == 1.) then

        delta_time = P_s(ii,4) + pfdt

        do while (P_s(ii,4) < delta_time)

            ! Find the "adjacent" cell corresponding to the particle's location
            Ploc(1) = floor(P_s(ii,1) / dx)
            Ploc(2) = floor(P_s(ii,2) / dy)

            Z = 0.
            do k = 1, nz
                Z = Z + dz_T(k)
                if (Z >= P_s(ii,3)) then
                    Ploc(3) = k - 1
                    exit
                end if
            end do

            ! check to make sure particles are in central part of the domain and if not
            ! apply some boundary condition to them
            ! check if particles are in domain, need to expand this to include better treatment of BC's
            if ((P_s(ii,1) < Xmin).or.(P_s(ii,2) < Ymin).or.(P_s(ii,3) < Zmin).or.  &
            (P_s(ii,1) >= Xmax).or.(P_s(ii,2) >= Ymax).or.(P_s(ii,3) >= (Zmax-dz_T(nz)))) then

            if ((P_s(ii,3) >= Zmax-(dz_T(nz)*0.5)).and.   &
            (Saturation_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) == 1.).and.  &
             (Vz_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) > 0.)) then

            !itime_loc = kk
            !if (itime_loc <= 0) itime_loc = 1
            !if (itime_loc >= pfnt) itime_loc = pfnt

            !Out_age_p = Out_age_p + P_s(ii,4)*P_s(ii,6)
            temp = atomicAdd(Out_age(1), P_s(ii,4)*P_s(ii,6))
            !Out_mass_p = Out_mass_p + P_s(ii,6)
            temp = atomicAdd(Out_mass(1), P_s(ii,6))

            if (P_s(ii,7) == 1.) then
            !Out_comp1_p = Out_comp1_p + P_s(ii,6)
            temp = atomicAdd(Out_comp(1), P_s(ii,6))
            end if

            if (P_s(ii,7) == 2.) then
            !Out_comp2_p = Out_comp2_p + P_s(ii,6)
            temp = atomicAdd(Out_comp(2), P_s(ii,6))
            end if

            if (P_s(ii,7) == 3.) then
            !Out_comp3_p = Out_comp3_p + P_s(ii,6)
            temp = atomicAdd(Out_comp(3), P_s(ii,6))
            end if

            !Out_np_p = Out_np_p + 1
            temp2 = atomicAdd(Out_np(1), int(lock))

            !flag particle as inactive
            P_s(ii,8) = 0.
            !flag as exiting via Outflow
            P_s(ii,10) = 1.
            goto 999

            end if
            ! otherwise we just leave it in the domain to reflect
            end if

            ! Find each particle's factional cell location
            Clocx = (P_s(ii,1) - float(Ploc(1))*dx)  / dx
            Clocy = (P_s(ii,2) - float(Ploc(2))*dy)  / dy

            Z = 0.
            do k = 1, Ploc(3)
                Z = Z + dz_T(k)
            end do
            Clocz = (P_s(ii,3) - Z) / dz_T(Ploc(3) + 1)

            ! Calculate local particle velocity using linear interpolation,
            ! converting darcy flux to average linear velocity

            Vpx = ((1.-Clocx)*Vx_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                  + Vx_T(Ploc(1)+2,Ploc(2)+1,Ploc(3)+1)*Clocx)   &
                  /(Porosity_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                  *Saturation_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))

            Vpy = ((1.-Clocy)*Vy_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                    + Vy_T(Ploc(1)+1,Ploc(2)+2,Ploc(3)+1)*Clocy) &
                    /(Porosity_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                    *Saturation_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))

            Vpz = ((1.-Clocz)*Vz_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                      + Vz_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+2)*Clocz)  &
                        /(Porosity_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                      *Saturation_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))

            ! calculate particle dt
            ! check each direction independently
            advdt = pfdt
            if (Vpx /= 0.) advdt(1) = abs(dtfrac*(dx/Vpx))
            if (Vpy /= 0.) advdt(2) = abs(dtfrac*(dy/Vpy))
            if (Vpz /= 0.) advdt(3) = dtfrac*(dz_T(Ploc(3)+1)/abs(Vpz))

            particledt = min(advdt(1), advdt(2), advdt(3), &
                      pfdt*dtfrac, delta_time-P_s(ii,4))

            ! calculate Flux in cell and compare it with the ET flux out of the cell
            if (EvapTrans_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) < 0.)then

            ! calculate divergence of Darcy flux in the cell
            !  in X, Y, Z [L^3 / T]
            !local_flux = (Vx_T(Ploc(1)+2,Ploc(2)+1,Ploc(3)+1) - Vx_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1)) +  &
            !             (Vy_T(Ploc(1)+1,Ploc(2)+2,Ploc(3)+1) - Vy_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1)) +  &
            !             (Vz_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+2) - Vz_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))
            !
            ! calculate ET flux volumetrically and compare to
            et_flux = abs(EvapTrans_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))*dx*dy*dz_T(Ploc(3)+1)

            ! compare total water removed from cell by ET with total water available in cell to arrive at a particle
            ! probability of being captured by roots
            ! water volume in cell
            water_vol = dx*dy*dz_T(Ploc(3)+1)*(Porosity_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1)  &
            *Saturation_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))
            !!  add that amout of mass to ET BT; check if particle is out of mass
            !itime_loc = kk
            !! extra checking for array bounds to provide future flexibilty
            !! if DT for output != PFDT
            !if (itime_loc <= 0) itime_loc = 1
            !if (itime_loc >= pfnt) itime_loc = pfnt
            Zr = ran1_gpu(ir,iff,ix1,ix2,ix3,j,r,rm1,rm2)
            if (Zr < ((et_flux*particledt)/water_vol)) then   ! check if particle is 'captured' by the roots
            !  this section made atomic since it could inovlve a data race
            !  that is, each thread can only update the ET arrays one at a time

            !ET_age_p = ET_age_p + P_s(ii,4)*P_s(ii,6)  ! mass weighted age
            temp = atomicAdd(ET_age(1), P_s(ii,4)*P_s(ii,6))

            !ET_mass_p = ET_mass_p + P_s(ii,6)  ! particle mass added to ET
            temp = atomicAdd(ET_mass(1), P_s(ii,6))

            if (P_s(ii,7) == 1.) then
            !ET_comp1_p = ET_comp1_p + P_s(ii,6)
            temp = atomicAdd(ET_comp(1), P_s(ii,6))
            end if

            if (P_s(ii,7) == 2.) then
            !ET_comp2_p = ET_comp2_p + P_s(ii,6)
            temp = atomicAdd(ET_comp(2), P_s(ii,6))
            end if

            if (P_s(ii,7) == 3.) then
            !ET_comp3_p = ET_comp3_p + P_s(ii,6)
            temp = atomicAdd(ET_comp(3), P_s(ii,6))
            end if

            !ET_np_p = ET_np_p + 1   ! track number of particles
            temp2 = atomicAdd(ET_np(1), int(lock))

            !outputting spatially distributed ET information
            temp = atomicAdd(C(6,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),lock)

            temp = atomicAdd(C(7,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_s(ii,6)) ! particle mass added to ET

            temp = atomicAdd(C(8,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_s(ii,4)*P_s(ii,6))  ! mass weighted age

            temp = atomicAdd(C(9,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_s(ii,7)*P_s(ii,6))  ! mass weighted contribution

            !now remove particle from domain
            P_s(ii,8) = 0.
            !flag as exiting via ET
            P_s(ii,10) = 2.

            goto 999
            end if
            end if

            !debuga(ii,1) = ploc(1)
            !debuga(ii,2) = ploc(2)
            !debuga(ii,3) = ploc(3)

            ! Advect particle to new location using Euler advection until next time
            P_s(ii,1) = P_s(ii,1) + particledt * Vpx
            P_s(ii,2) = P_s(ii,2) + particledt * Vpy
            P_s(ii,3) = P_s(ii,3) + particledt * Vpz
            P_s(ii,4) = P_s(ii,4) + particledt

            Ltemp = SQRT((particledt*Vpx)**2 + (particledt*Vpy)**2 + &
                         (particledt*Vpz)**2)

            ! Molecular Diffusion
            if (moldiff > 0.) then
            z1 = 2.*SQRT(3.)*(ran1_gpu(ir,iff,ix1,ix2,ix3,j,r,rm1,rm2)-0.5)
            z2 = 2.*SQRT(3.)*(ran1_gpu(ir,iff,ix1,ix2,ix3,j,r,rm1,rm2)-0.5)
            z3 = 2.*SQRT(3.)*(ran1_gpu(ir,iff,ix1,ix2,ix3,j,r,rm1,rm2)-0.5)

            P_s(ii,1) = P_s(ii,1) + z1 * SQRT(moldiff*2.*particledt)
            P_s(ii,2) = P_s(ii,2) + z2 * SQRT(moldiff*2.*particledt)
            P_s(ii,3) = P_s(ii,3) + z3 * SQRT(moldiff*2.*particledt)

            Ltemp = Ltemp + &
                         SQRT((z1*SQRT(moldiff*2.*particledt))**2 + &
                              (z2*SQRT(moldiff*2.*particledt))**2 + &
                              (z3*SQRT(moldiff*2.*particledt))**2)
            end if
            P_s(ii,11) = P_s(ii,11) + Ltemp
!!  placeholder for other interactions; potentially added later
!!
            ! place to track saturated / groundwater time if needed
            if(Saturation_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) == 1.) then
              P_s(ii,5) = P_s(ii,5) + particledt
              P_s(ii,12) = P_s(ii,12) + Ltemp
            end if

            if (nind > 0) then
              !itemp=int(Ind(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))
              if(int(Ind_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1)) > 0 .and. &
                 int(Ind_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1)) <= nind) then

                P_s(ii,12+int(Ind_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))) = &
                P_s(ii,12+int(Ind_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))) + particledt

                P_s(ii,12+nind+int(Ind_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))) = &
                P_s(ii,12+nind+int(Ind_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))) + Ltemp
              end  if
            end if

            ! simple reflection boundary
            if (P_s(ii,3) >=Zmax) P_s(ii,3) = Zmax- (P_s(ii,3) - Zmax)
            if (P_s(ii,1) >=Xmax) P_s(ii,1) = Xmax- (P_s(ii,1) - Xmax)
            if (P_s(ii,2) >=Ymax) P_s(ii,2) = Ymax- (P_s(ii,2) - Ymax)
            if (P_s(ii,2) <=Ymin) P_s(ii,2) = Ymin+ (Ymin - P_s(ii,2))
            if (P_s(ii,3) <=Zmin) P_s(ii,3) = Zmin+ (Zmin - P_s(ii,3))
            if (P_s(ii,1) <=Xmin) P_s(ii,1) = Xmin+ (Xmin - P_s(ii,1))

            ! write all active particles at concentration in ASCII VisIT 3D file format continuously
            ! as noted above, this option is very slow compared to VTK binary output
            !if (ipwrite < 0) then
            !  if (P_s(ii,8) == 1.) write(214,61) P_s(ii,1), P_s(ii,2), P_s(ii,3), P_s(ii,4)
            !flush(214)
            !end if !! ipwrite


        end do  ! end of do-while loop for particle time to next time
        999 continue   ! where we go if the particle is out of bounds

            ! concentration routine
            ! Find the "adjacent" "cell corresponding to the particle's location
            Ploc(1) = floor(P_s(ii,1) / dx)
            Ploc(2) = floor(P_s(ii,2) / dy)
            Z = 0.
            do k = 1, nz
                Z = Z + dz_T(k)
                if (Z >= P_s(ii,3)) then
                        Ploc(3) = k - 1
                        exit
                end if
            end do

            temp = atomicAdd(C(1,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_s(ii,8)*P_s(ii,6) /  &
            (dx*dy*dz_T(Ploc(3)+1)*(Porosity_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1)   &
             *Saturation_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))))

            temp = atomicAdd(C(2,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_s(ii,8)*P_s(ii,4)*P_s(ii,6))

            temp = atomicAdd(C(4,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_s(ii,8)*P_s(ii,7)*P_s(ii,6))

            temp = atomicAdd(C(3,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_s(ii,8)*P_s(ii,6))

            temp = atomicAdd(C(5,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_s(ii,8)*P_s(ii,9)*P_s(ii,6))

    end if

    P(ii_g,:) = P_s(ii,:)
    !call syncthreads()

  end do
!=============================================================================
    !out_age_s(ii)    = out_age_p
    !out_mass_s(ii)   = out_mass_p
    !out_comp1_s(ii)  = out_comp1_p
    !out_comp2_s(ii)  = out_comp2_p
    !out_comp3_s(ii)  = out_comp3_p
    !out_np_s(ii)     = out_np_p
    !et_age_s(ii)     = et_age_p
    !et_mass_s(ii)    = et_mass_p
    !et_comp1_s(ii)   = et_comp1_p
    !et_comp2_s(ii)   = et_comp2_p
    !et_comp3_s(ii)   = et_comp3_p
    !et_np_s(ii)      = et_np_p
!
    !call syncthreads()
!=============================================================================
  !k = blockDim%x/2
  !do while ( k >= 1)
  !    if (ii <= k) then
  !      out_age_s(ii)   = out_age_s(ii)   + out_age_s(ii+k)
  !      out_mass_s(ii)  = out_mass_s(ii)  + out_mass_s(ii+k)
  !      out_comp1_s(ii) = out_comp1_s(ii) + out_comp1_s(ii+k)
  !      out_comp2_s(ii) = out_comp2_s(ii) + out_comp2_s(ii+k)
  !      out_comp3_s(ii) = out_comp3_s(ii) + out_comp3_s(ii+k)
  !      out_np_s(ii)    = out_np_s(ii)    + out_np_s(ii+k)
  !      et_age_s(ii)    = et_age_s(ii)    + et_age_s(ii+k)
  !      et_mass_s(ii)   = et_mass_s(ii)   + et_mass_s(ii+k)
  !      et_comp1_s(ii)  = et_comp1_s(ii)  + et_comp1_s(ii+k)
  !      et_comp2_s(ii)  = et_comp2_s(ii)  + et_comp2_s(ii+k)
  !      et_comp3_s(ii)  = et_comp3_s(ii)  + et_comp3_s(ii+k)
  !      et_np_s(ii)     = et_np_s(ii)     + et_np_s(ii+k)
  !    end if
  !    k = k / 2
  !    call syncthreads()
  !end do
!
  !if(ii == 1) then
  !  temp     = atomicAdd(out_age(1),    out_age_s(1)  )
  !  temp     = atomicAdd(out_mass(1),   out_mass_s(1) )
  !  temp     = atomicAdd(out_comp(1),out_comp1_s(1))
  !  temp     = atomicAdd(out_comp(2),out_comp2_s(1))
  !  temp     = atomicAdd(out_comp(3),out_comp3_s(1))
  !  temp2    = atomicAdd(out_np(1),     out_np_s(1)   )
  !  temp     = atomicAdd(et_age(1),     et_age_s(1)   )
  !  temp     = atomicAdd(et_mass(1),    et_mass_s(1)  )
  !  temp     = atomicAdd(et_comp(1), et_comp1_s(1) )
  !  temp     = atomicAdd(et_comp(2), et_comp2_s(1) )
  !  temp     = atomicAdd(et_comp(3), et_comp3_s(1) )
  !  temp2    = atomicAdd(et_np(1),      et_np_s(1)    )
  !end if
!
  !call syncthreads()

 end subroutine particles_independent
!=============================================================================
      attributes(device) function ran1_gpu(idum,iff,ix1,ix2,ix3,j,r,rm1,rm2)
        implicit none  !note after use statement
        real*8 ran1_gpu
        integer, intent(inout), optional :: idum
        real*8 r(97),rm1,rm2
        integer, parameter :: m1=259200,ia1=7141,ic1=54773
        integer, parameter :: m2=134456,ia2=8121,ic2=28411
        integer, parameter :: m3=243000,ia3=4561,ic3=51349
        integer j
        integer iff,ix1,ix2,ix3
        !data iff /0/
        !iff = 0
!        save iff,ix1,ix2,ix3,j,r,rm1,rm2
        if(present(idum))then
          if (idum<0.or.iff.eq.0)then
            rm1=1.0/m1
            rm2=1.0/m2
            iff=1
            ix1=mod(ic1-idum,m1)
            ix1=mod(ia1*ix1+ic1,m1)
            ix2=mod(ix1,m2)
            ix1=mod(ia1*ix1+ic1,m1)
            ix3=mod(ix1,m3)
            do j=1,97
                ix1=mod(ia1*ix1+ic1,m1)
                ix2=mod(ia2*ix2+ic2,m2)
                r(j)=(real(ix1)+real(ix2)*rm2)*rm1
            enddo
            idum=1
          endif
        endif
        ix1=mod(ia1*ix1+ic1,m1)
        ix2=mod(ia2*ix2+ic2,m2)
        ix3=mod(ia3*ix3+ic3,m3)
        j=1+(97*ix3)/m3
        !if(j>97.or.j<1)then
        !    write(*,*)' error in ran1_gpu j=',j
        !    stop
        !endif
        ran1_gpu=r(j)
        r(j)=(real(ix1)+real(ix2)*rm2)*rm1
        return
     end function ran1_gpu
end module particles_para_cuda_m
